# prompts.yaml

suggest_semantic_columns: |
  Analyze the following table schema and sample data to identify columns containing free-form text suitable for semantic search (embedding). Semantic search is used for finding similar descriptions, understanding meaning, or searching based on concepts rather than exact values.

  Table Name: {table_name}

  Schema (Columns and Types - Inferred):
  {schema_str}

  Sample Data (First 5 Rows):
  {df_head_str}

  Identify the column names from the schema list that contain natural language text, descriptions, notes, or comments that would be valuable for semantic search. Exclude IDs, numerical values, dates, codes, categories (unless the categories themselves have descriptive names), or URLs unless the URL text itself is descriptive.

  Respond ONLY with a valid JSON list of strings containing the suggested column names. Example: ["product_description", "customer_review_text"]
  If no columns seem suitable, respond with an empty JSON list: []

  Suggested Columns JSON:

# Used by _route_query (structured output) and route_query_wrapper
route_query_structured: |
  Analyze the context and user query to determine the best approach.

  Database Schema:
  {schema}
  {sample_data}
  User Query:
  "{user_query}"

  Carefully consider the query's intent:
  - Choose "SQL" if the query requires precise data retrieval, filtering, aggregation (counts, sums, averages), or specific values matching the schema columns.
  - Choose "SEMANTIC" if the query asks for descriptions, meaning, similarity, or information likely found in unstructured text columns (like product descriptions, notes, etc.).

  Respond ONLY with a valid JSON object containing a single key "query_type" whose value is either the string "SQL" or the string "SEMANTIC". Example: {{"query_type": "SQL"}}

# Base prompt for SQL generation
generate_sql_base: |
  You are an expert SQL generator.
  
  Given the following information:
  
  **Database Schema (in JSON format):**
  {schema}
  
  **Data Sample (representative sample of the target table):**
  {sample_data}
  
  **User Query:**
  {user_query}
  
  **Augmented Keywords:**
  {augmented_keywords}
  
  Generate an SQLite query to answer the user’s query. Follow these rules:
  
  1. Select either `*` or a combination of key and relevant value columns.
  2. Use appropriate numerical comparisons (for example, write `COUNT < 5` instead of `COUNT < 5 units`).
  3. When filtering textual fields, incorporate both the exact keyword(s) from the query and the additional augmented keywords (using the LIKE operator for partial matches). Note that SQLite does not support ILIKE; for case-insensitive matching use LOWER(column) LIKE LOWER('%keyword%').
  4. Handle extremes such as min/max using subqueries (if needed) to include ties.
  5. Avoid unnecessary clauses like ORDER BY or LIMIT unless they are required to answer the query.
  6. Do not modify the database schema or data.
  
  **Respond ONLY with the complete SQLite query, ending with a semicolon.**
  

# Addendum for SQL generation retries based on feedback
generate_sql_feedback_syntax: |

  PREVIOUS ATTEMPT FAILED due to a syntax error.
  Incorrect SQL: `{previous_sql}`
  Error: "{feedback}"
  Please correct the syntax.

generate_sql_feedback_other: |

  PREVIOUS ATTEMPT was unsatisfactory.
  SQL Executed: `{previous_sql}`
  Reason: "{feedback}"
  Please generate an improved query incorporating this feedback.

# Final instruction for SQL generation response format
generate_sql_response_format: |

  Respond ONLY with the SQLite query, ending with a semicolon.
  SQLite Query:

# Prompt for validating SQL results
validate_sql_results: |
  You are validating SQL query results.
  User's original query: "{user_query}"
  Executed SQL query: `{executed_sql}`
  Data returned (sample):
  {context_str}

  Does the returned data accurately and completely answer the user's original query? Consider if the filtering, ordering, and selected columns are appropriate.

  Respond ONLY with a valid JSON object with two keys:
  1. "satisfactory": boolean (true if the data answers the query, false otherwise).
  2. "reason": string (if false, a BRIEF explanation of why, e.g., "missing filter for category", "wrong ordering", "needs different columns". If true, this can be an empty string or null).
  Example if unsatisfactory: {{"satisfactory": false, "reason": "The query returned the highest price, but the user asked for the cheapest."}}
  Example if satisfactory: {{"satisfactory": true, "reason": ""}}

# Prompt to check if query is English
check_language: |
  Is the following query primarily written in English? Respond only with YES or NO.

  Query: "{user_query}"

# Prompt to translate a query to English
translate_to_english: |
  Translate the following query accurately into English. Respond ONLY with the English translation.

  Query: "{user_query}"

  English Translation:

# Prompt for summarizing requirements from conversation history
derive_requirements_from_history: |
  You are an expert data assistant. Based on the following conversation history between a user and an assistant, derive a concise summary of the user's real requirements for searching the database. Focus on any specific filters, desired aggregations, or conditions mentioned by the user.

  Conversation History:
  {context}

  Please provide a refined summary of the user's requirements that can be used to generate the best search query for the latest message by the user.
  Refined Requirements:

# Consolidated prompt for refining query, selecting table, and determining route
refine_and_select: |
  You are an expert data analyst assisting a user querying a database with potentially multiple tables. Your primary goal is to determine the correct table and the best way to query it based on the user's request and the available data structure.

  **Inputs:**
  1. **Conversation History (Last few turns):**
     {recent_context}
  2. **User's Latest Query:** "{user_query}"
  3. **Database Schema (Target Table and Columns):**
     {schema}
  4. **Sample Data (First few rows of a key table)):**
      {sample_data}  

  **Analysis Steps & Output Instructions:**
  Perform the following steps and structure your response as a single JSON object:

  1. **Identify the Most Relevant Table:**
     - Analyze the **User's Latest Query** and the **Conversation History**.
     - Examine the **Database Schema**, paying close attention to the **column names** in each table.
     - Determine which **single table** from the schema is most likely to contain the information needed to answer the query.
     - **Output Key:** `"selected_table"`: string (The name of the single most relevant table.)

  2. **Augment the Query with Additional Keywords:**
     - Analyze the **User's Latest Query** to identify exact keywords provided by the user.
     - Also determine one or more augmented keywords or phrases that are semantically related and might improve retrieval coverage.
     - **Output Key:** `"augmented_keywords"`: list of strings (Additional keywords or phrases that complement the original query.)

  3. **Determine the Query Route:**
     - Based on the nature of the **Refined Query** and the likely data types in the **Selected Table’s** columns, decide whether to use an exact SQL query ('SQL') for structured retrieval or semantic search ('SEMANTIC') for unstructured text.
     - **Output Key:** `"route"`: string ("SQL" or "SEMANTIC")

  **Respond ONLY with a valid JSON object containing these keys.**
  The JSON object should be structured as follows:
  
  **Example 1 (SQL Route):**
  ```json
  {
      "refined_query": "Calculate the total sales amount for the product 'Laptop' in the month of June 2024.",
      "augmented_keywords": ["Laptop", "sales total", "June 2024"],
      "route": "SQL"
  }
  
  **Example 2 (Semantic Route):**

  ```json      
  {
      "refined_query": "Find products with descriptions similar to 'lightweight and portable laptop for travel'.",
      "augmented_keywords": ["lightweight", "portable", "travel", "laptop"],
      "route": "SEMANTIC"
  }

    

# Prompt for generating the final natural language summary
generate_final_summary: |
  Based only on the following retrieved data (which may include SQL results, semantic search snippets, or both), provide a concise and helpful natural language answer to the user's original query. If both SQL and semantic results are present, try to synthesize them. If one or both are empty or irrelevant, state that.

  User Query: "{original_query}"{translated_context}

  Retrieved Data:
  ---
  {summary_context}
  ---

  Answer:

select_database_id: |
  You are a database schema expert. Your task is to identify the SINGLE most relevant database ID to answer the user's query, given a list of databases and their detailed schemas (tables and columns).

  **Instructions:**
  1. Analyze the **User Query** carefully.
  2. Examine the schemas provided under **Available Databases**. Pay close attention to **table names AND column names** within each database ID.
  3. Match keywords, concepts, and entities mentioned in the query to the database that most likely contains the relevant tables and columns.
  4. Respond ONLY with the single database ID string (the top-level key from the schema list) that is the best fit. Do not add any explanation.

  **Available Databases (Schema Details & Sample Data Snippet):**
  ```json
  {formatted_schemas_and_samples_str}


  ** User Query:** {user_query}
